怎么解决并发同步问题？
    加锁，使同一时刻只能有一个线程访问共享内存

什么是锁？


Java 中如何加锁？
    volatile 关键字： 注意不能完全的保证原子性
    synchronized 关键字
    Lock 类


synchronized 关键字用法
    对象锁：
        修饰实例方法： public synchronized void func(){} , 默认锁定的是 this 实例
        修饰代码块： synchronized(instance){}
    类锁：
        修饰类方法： public static synchronized void func(){} , 默认锁定的是当前类的 Class 类的实例
        修饰代码块： synchronized(*.class){}

Summarize 总结：
    1. 每个实例（类本身实例 和 类创建实例）都有一把锁，只有请求同一把锁的线程会被阻塞
    2. synchronized 代码块（方法的话是方法体）结束或者其中抛出异常，则会立马释放所拥有的锁
    3. synchronized 代码块（方法的话是方法体）中调用非同步方法，那么其中的非同步方法是会存在并发问题的

synchronized 关键字的缺陷：
    1. 效率低：
        锁的释放场景少: 只会在同步代码块执行完或者抛异常才释放锁
        试图获得锁时不能设定超时时间：
        不能中断一个正在试图获得锁的线程：
    2. 不够灵活：
        加锁和释放锁的时机单一：只会在进入同步代码块的时候加锁，在执行完和抛异常的时候释放锁，不如读写锁（读操作的时候不加锁，写操作的时候才加锁）灵活
        每个锁仅有单一的条件（某个实例）：Lock 锁可以用 Condition 判断什么情况下才加锁
        无法知道是否成功的获取到锁

synchronized 关键字底层原理是什么？
    通过 Monitor 来对代码加锁和解锁

synchronized 同时只有一个线程可以执行，性能较差，有什么办法可以提升性能？
    1. 缩小同步代码块；
    2. 使用读写锁

多线程访问同步方法时的串行、并行问题？
    1. 两个线程访问同一个实例的同步方法：串行
    2. 两个线程访问两个实例的同步方法：并行
    3. 两个线程访问同一个类的多个实例的静态同步方法：串行
    4. 两个线程 A、B， 在同一个时刻，A 访问同步方法，B 访问非同步方法：并行
    5. 两个线程 A、B， 在同一个时刻，A 访问同步方法 a，B 访问同步方法 b：串行，因为不同的同步方法锁定的对象都是当前实例 this
    6. 两个线程 A、B， 在同一个时刻，A 访问静态同步方法 a，B 访问非静态同步方法 b： 并行，因为两个锁定的对象不是一个，一个是 Class 对象的实例，一个是 Custom 的 this 实例


    
Lock 接口的实现类有哪些？
    ReentrantLock
    ReentrantReadWriteLock$WriteLock
    ReentrantReadWriteLock$ReadLock

什么是公平锁、非公平锁？
    公平锁：下一个获取锁的线程是等待最久的那个线程
    非公平锁：随机从等待线程中取一个赋予锁

synchronized 和 Lock 锁的区别？
    1. 一个是关键字，一个是类
    2. synchronized 无法判断获取锁的状态，Lock 可以判断是否获取到了锁
    3. synchronized 会自动释放锁（包括抛异常），Lock 必须要手动释放锁！如果不释放锁，那么会死锁
    4. synchronized 没有获取到锁会一直等待，Lock 锁可以使用 tryLock() 方法设定等待锁的时间
    5. synchronized 是可重入锁，非公平锁，不可修改，因为是关键字，Lock 可重入锁，可以判断锁，非公平可以自己设置
    6. synchronized 适合锁少量的代码同步问题，Lock 适合锁大量的同步代码

    什么是锁的升级、降级？什么是 JVM 里的偏斜锁、轻量级锁、重量级锁？
