Java 容器中判断两个对象是否相等：
    obj1 == obj2; 判断两个对象的地址是否相等
    obj1.equals(obj2); 在未重写的情况下与 == 运算符一样，也是判断地址


HashMap 实现原理？
    底层是一个 Entry[] , 每一个 Entry 实例保存一对 key value，且 Entry 实例包含 next 指针，可以形成 链表，
    jdk8 中转成红黑树的话，Entry 就是 红黑树的节点

Hash 冲突的解决方案有哪些？
    1. 做成链表
    2. 开放地址法(再散列法)：
        对内容 A 计算出哈希值 P，如果冲突以 P 当做内容，再次计算哈希值，依次类推，
        通用再散列公式：Hi=（H（key）+ di）% m   i = 1, 2, ..., n  其中 di 是每次再散列需要变动的值，m 为数组长度
        a. 线性探测再散列：di = 1, 2, ..., m-1
            特点是：冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。
        b. 二次探测再散列：di = 1^2, -1^2, 2^2, -2^2, ..., k^2, -k^2    ( k<=m/2 )
            特点是：冲突发生时，在表的左右进行跳跃式探测，比较灵活。
        c. 伪随机探测再散列: di = 伪随机数序列
            特点是：需要一个随机数发生器，并定义随机数种子

    3. 建立公共溢出区：开辟一个区间，专门存放冲突的内容
    4. 再哈希法：同时存在多个哈希函数，第一个冲突，用第二个，以此类推

链表 可以替代 HashMap 中数组吗？
    可以，
    那为什么不用链表呢？
        因为数组有下标，可以直接定位内存地址，效率高啊
    ArrayList 底层也是数组，为什么不用 ArrayList 而是用纯粹的 Array 呢？
        因为纯粹的 Array 可定制性强啊，比如扩容算法等，想咋玩就咋玩，别人封装好的东西就不能动了

HashMap 在什么情况下扩容？
    当数组使用率超过 容量*负载因子 就会 resize
    为什么扩容是 2 的 n 次幂呢？
        1. 为了存取高效，计算 hashCode 的算法要尽量减少碰撞，把数据均匀的分配到数组中，且尽量使不同链表的长度大致相同，
           所以 计算 index 的算法是对数组长度进行取余操作，如 index = hashCode%length
           因为  hashCode%length 的运算在计算机中肯定没有位运算来的快，所以优化过的算法为 hashCode&(length-1)
           也就是说 hashCode%length 和 hashCode&(length-1) 结果是一样的
        2. 因为 2^n 用二进制表示为 1000 .... , 2^n-1 用二进制表示为 0111 ....
           在进行按位与操作时，与的都是 1，在不同位置上，不会出现 hash 碰撞，如果容量不是 2^n 就有可能出现 hash 碰撞，
           为了保证上面所说的效率，所有容量都是 2^n
    为什么要先 高16位 和 低16位 进行一次 异或操作后 再进行取余操作？
        假设 ary.length = 16 , 进行 index = hashCode&(length-1) 计算
        如果不进行异或操作（这里只使用 高4位 异或 低4位 演示）
        1010 0000 & 0000 1111 = 0000 0000
        1011 0000 & 0000 1111 = 0000 0000
        1111 0000 & 0000 1111 = 0000 0000

        如果进行异或操作
        (1010 0000 ^ 0000 1010) & 0000 1111 = 0000 1010
        (1011 0000 ^ 0000 1011) & 0000 1111 = 0000 1011
        (1111 0000 ^ 0000 1111) & 0000 1111 = 0000 1111

        由以上结果反映，
        当不进行异或操作时，只要 低4位 为 0 ，无论高位怎么变化，最后的 index 都一样，即 hash 碰撞
        如果做了异或操作，就可以减少 hash 碰撞

HashMap get 和 put 的过程是什么样的？
    put 过程：
        1. 对 key 用 hashCode() 做 hash 运算，得到 index
        2. 将 key value 封装成 Entry 实例放入到数组中，如果发生碰撞，那么接到链表后面
        4. equals 判断 key 是否已经存在，已存在则替换 old value
        5. 如果 bucket 满了就要进行 resize
    get 过程：
        与 put 过程相反

String 类型 hashCode() 方法的代码是怎样的？
    待看

JDK8 中 HashMap 改了什么？
    1. 从 数组+链表 改为 数组+链表+红黑树
    2. 优化了高位运算的 hash 算法：h^(h>>>16)
    3. 扩容后，假设容量从 8 扩展到 16 ，元素要么在原来的 index  下，要么是在位置为 index + 8 的扩容出来的索引下，且链表顺序不变，如何实现的？
        jdk7 时，扩容会对所有 key 重新进行 hashCode() 计算，并重新插入链表
        jdk8 是根据新增的 bit 位是否为 0 判断，是否在原位置，0 则在原位置，1 在原位置加上扩展数量（原数组长度）的新位置


为什么不直接使用 红黑树 而是先用 链表 再用 红黑树？
    1. 对数函数O(logn) 和 指数函数O(n) 在数据量小的时候查询性能差距并不大，而红黑树需要进行左旋、右旋、染色等操作，反而降低了插入性能
    为什么长度在 8 的时候转换成红黑树？
        可能是在长度为 8 的时候，才能体现出红黑树的优势，或者使用红黑树，不会造成性能损失
    什么时候红黑树退化为链表？为什么为该数值？
        长度为 6 时，因为 6 和 8 之间有个缓冲区，防止频繁转换，浪费性能






HashMap 在并发环境下有什么问题？
    1. 多线程扩容，导致死循环问题
    2. 多线程 put，导致数据丢失
       A 线程获取链表尾后挂起，B 线程插入数据，导致链表尾更新，然后 A 线程继续就会覆盖 B 线程插入的数据
    3. put 非 null，get 出来却是 null



一般用什么作为 HashMap 的 key ？ null 可以作为 key 吗？
    一般用 Integer String 这种不可变类作为 key，而且 String 最常用

    为什么 String 作为 key 比较好？
        1. 因为 String 是不可变类，String 的 hashCode 被缓存在对象中了，不需要重新计算，处理数组快
        2. String 类已经很规范的重写了 HashMap 存取时要用到的 hashCode() 和 equals() 方法了

    用可变类作为 key 有什么问题？
        可变类会导致两次计算的 hashCode 值不同，导致 put 进去 get 不出来

    自定义实现一个类最为 HashMap 的 key 该如何实现？
        规范的重写 hashCode() 和 equals() 方法
            (1)两个对象相等，hashcode一定相等
            (2)两个对象不等，hashcode不一定不等
            (3)hashcode相等，两个对象不一定相等
            (4)hashcode不等，两个对象一定不等
        自定义类必须是不可变类
            类添加 final 修饰符，保证不被继承
            所有类成员变量都必须用 private final 修饰
            不提供 setter 方法
            通过构造函数初始化所有成员变量
            getter 方法中不直接返回实例，而是返回 clone 的实例

HashMap 为什么线程不安全？
    A，B 两个线程同时往 HashMap 中插入数据，且两个 key 的 hashCode 一样，
    A 线程获取到了指定 index 下的 Head 指针，然后 B 线程也同时获得了 Head 指针，然后 B 写数据，A 在写数据，
    因为 A 获得的还是最初版的 Head 指针，所以 A 写的内容会覆盖 B 写的内容

ConcurrentHashMap 为什么比 HashTable 效率高？
    ConcurrentHashMap 使用分段锁技术提高了并发度，每个段一把锁，对不同段操作互不影响
