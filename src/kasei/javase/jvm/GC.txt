对象是否可回收判断算法：
    可达性分析法：以图论来理解，就是从 GC Root 到这个对象不可达时，回收这个对象


GC Algorithm：
    标记-复制法：
    标记-清除法：
    标记-整理法：
    
GC 执行算法：
    古典时代：
        Serial(年轻代), SerialOld(老年代)                   # 垃圾回收时暂停业务线程，单个 GC 线程执行垃圾回收
        Parallel Scavenge(年轻代), Parallel Old(老年代)     # 垃圾回收时暂停业务线程，多个 GC 线程执行垃圾回收
    中古时代：
        ParNew(年轻代):                            # 仅适用于年轻代
        CMS(老年代): Concurrent Mark Sweep         # 标记时不暂停业务线程，只适用于 老年代，不进行 Compact，最新 JDK 已删除
    现代：
        G1: 不再是连续的 eden survivor1 suvivor2 tenured 内存结构，而是跟硬盘一样进行了分区，每个区大小相同
            Fully Young GC：
            Mixed GC：包含一次 Fully Young GC
    未来：
        ZGC: Oracle 实现的
        Shenandoah: Red Hat 实现的
    

GC ROOT：
    栈帧中的本地变量中引用的实例（对象）
    方法区中静态成员引用的实例
    方法区中 final 常量引用的实例
    本地方法栈中 JNI（即 Native 方法）引用的实例

GC Algorithm：
    复制法：
    标记-清除：
    标记-整理：

GC 种类：
    收集器             串行、并行or并发       新生代/老年代     算法              目标              适用场景
    Serial              串行                  新生代         复制算法        响应速度优先      单CPU环境下的Client模式
    ParNew              并行                  新生代         复制算法        响应速度优先      多CPU环境时在Server模式下与CMS配合
    Parallel Scavenge   并行                  新生代         复制算法        吞吐量优先        在后台运算而不需要太多交互的任务
    
    Serial Old          串行                  老年代         标记-整理       响应速度优先      单CPU环境下的Client模式、CMS的后备预案
    Parallel Old        并行                  老年代         标记-整理       吞吐量优先        在后台运算而不需要太多交互的任务
    CMS                 并发                  老年代         标记-清除       响应速度优先      集中在互联网站或B/S系统服务端上的Java应用
    G1                  并发                  both       标记-整理+复制算法  响应速度优先      面向服务端应用，将来替换CMS


引用：判定对象是否存活都与"引用"有关,Java对引用概念进行了扩充。
    强引用（Strong Reference）
    软引用（Soft Reference）
    弱引用（Weak Reference）
    虚引用（Phantom Reference）



System.gc(); // 手动调用垃圾回收器，这样垃圾对象就会尽可能快的被回收，避免垃圾回收器的延时
